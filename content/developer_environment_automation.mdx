# Developer Environment and Automation

<img src={'https://images.unsplash.com/photo-1505238680356-667803448bb6?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80'} altText />

For more than 7 years I am working professionally as a software engineer. During this time I put together a nice developer setup. This article is my attempt to review it, improve it and share it with others.

Most of the time I spend in **command line**, writing code in **Vim**, executing commands in **Zsh** shell, switching panes and sessions in **Tmux**  and all that is rendered in **Alacritty** terminal emulator running on my Mac.

What my developer environment consists of?

* MacOS as main operation system
* Ansible for installation and configuration
* Alacritty as a terminal emulator
* ZSH as command interpreter (shell)
* Tmux as a terminal multiplexer (sessions, panes)
* Nvim as the main text editor

## Configuration automation

My enviroment consists of many tools and programs. More or less they all require some manual installation and configuration. To make life easier I keep all setup and configuration instructions in `Git` repository as Ansible provisioning scripts.

Each time I need to recreate my environment, I use [env-automation][env-automation]. I donwnload it, run init.sh script and in 20-30 minutes laptop is ready for work. Project automatically installs and configures everything starting from setting basic macOS settings, like disabling animations, to installing Google Chrome and Spotify.

Ansible is a provisioning tools which is heavily used in DevOps. It is mainly used to install and configure software on servers in reproducible way. Even though it is mainly used to provision servers, it works great to provision my machine as well.

Ansible defines conpect of Playbook and Role. Role defines how to install and configure some software component. Each role can contain tasks, variables, files, templates. For example the `Git` role makes sure git is present and global `~/.gitconfig` config file is generated.

```yml
---
- name: Make sure git is present
  homebrew:
    name:
      - git
    state: present

- name: Make sure .gitconfig is present
  template:
    src: templates/.gitconfig.j2
    dest: ~/.gitconfig
```

Playbook defines what set of Roles are going to installed on target machine. For example playbook that is used to provision my machine:

```yml
---
- hosts: local
  vars_files:
    - vars/variables.yml
    - vars/global_env.yml
  roles:
    - {role: 'macos', tags: 'macos'}
    - {role: 'packages', tags: 'packages'}
    - {role: 'git', tags: 'git'}
    - {role: 'python', tags: 'python'}
    - {role: 'ssh', tags: 'ssh'}
    - {role: 'asdf-vm', tags: 'asdf-vm'}
    - {role: 'zsh', tags: 'zsh'}
    - {role: 'tmux', tags: 'tmux'}
    - {role: 'vim', tags: 'vim'}
    - {role: 'alacritty', tags: 'alacritty'}
    - {role: 'aws', tags: 'aws'}
    - {role: 'golang', tags: 'golang'}
    - {role: 'jvm', tags: 'jvm'}
    - {role: 'clojure', tags: 'clojure'}
    - {role: 'docker', tags: 'docker'}
    - {role: 'node', tags: 'node'}
```

## Terminal - Alacritty

When you havily use command line, espessially when you search, move around, or write code in Nvim - you expect you terminal to render text fast. At some point I was frustrated with performance of my terminal. I started searching for solution and found [Alacritty][Alacritty Github].

> Alacritty is the fastest terminal emulator in existence.

Alacritty is fast and simple. It is written in Rust and uses GPU acceleration for rendering. There is no GUI features like windows, tabs or splits. It's just one very performant window. Nothing more than I need. For windows, tabs and splits I use Tmux, which works pretty well in combination.

Alacritty ansible role:

```yml
---
- name: Make sure alacritty is present
  homebrew_cask:
    name: alacritty
    state: present

- name: Make sure config directory is present
  file:
    path: ~/.config/alacritty
    state: directory

- name: Make sure config file is present
  template:
    src: templates/alacritty.yml.j2
    dest: ~/.config/alacritty/alacritty.yml
```


I'm using it with `Fira Code` font, but want to warn you about very sad fact - Alacritty doesn't support font ligatures. I hope it will be added soon.

```yml
font:
  normal:
    family: Fira Code
    style: Regular
  bold:
    family: Fira Code
    style: Bold
  italic:
    family: Fira Code
    style: Italic
  size: 14.0
```

My favorite shell is `Zsh`, to set up Alacritty to start `Zsh` by default, add:

```yml
shell:
  program: /usr/local/bin/zsh
  args:
    - --login
```

Lastly, I added next line to be able to send `^`, when you type `<ctrl>6`, to Vim to switch between files:
```yml
key_bindings:
  - {key: Key6, mods: Control, chars: "\x1e"}
```

I am constantly updating my enviroment, make sure you subscribed on `env-automation`, full Alacritty configuration file you can find here [.alacritty.yml](https://github.com/atsman/env-automation/blob/master/roles/alacritty/templates/alacritty.yml.j2)

## Terminal Multiplexer - Tmux

Alacritty provides me only with very fast and simple window. To be able to have multiple tabs and splits like in `iTerm2`, I use [Tmux][Tmux Github] terminal miltiplexer. 

Let's understand terminology:

* **sessions**: list of terminals under Tmux control, each session has one or more windows
* **window**: window takes one screen and can be splitted into panes
* **pane**: smallest part of the window

If you are `iTerm` user, you can think about Window, like about tab.

Usually I have session per project open and multiple windows in each session. For example I can have session `work`, with 2 windows open, one for code in Nvim and one window for running build scripts and tests.

Tmux heavily rooted in my workflow. It allows to quickly navigate between sessions, between panes and split panes. It is configured to support Vim key bindings to navigate between split panes and be able to select and copy text from output log.

### Tmux - Plugins

* [tmux-plugins/tpm](https://github.com/tmux-plugins/tpm) - plugin manager 
* [tmux-plugins/tmux-sensible](https://github.com/tmux-plugins/tmux-sensible) - predefined settings
* [tmux-plugins/tmux-yank](https://github.com/tmux-plugins/tmux-yank) - copy to system clipboard
* [tmux-plugins/tmux-copycat](https://github.com/tmux-plugins/tmux-copycat) - regex search
* [tmux-plugins/tmux-open](https://github.com/tmux-plugins/tmux-open) - open highlighted selection
* [vim-tmux-navigator](https://github.com/christoomey/vim-tmux-navigator) - seamless navigation between tmux and vim

### Tmux - Shortcuts

First you need to configure your prefix key. My prefix is `<ctrl>a`. All commands start with me holding `<ctrl>a` and typing one more symbol. For example to create new window I have to type`<ctrl>a c`

```
<c-a> - Prefix
<prefix>r - reload config
```

#### Panes

```
<prefix>c - create new pane
<prefix>h - toggle panes line
<prefix>1 - go to pane 1
<prefix>2 - go to pane 2
.
<prefix><N> - go to pane N
```

#### Splits

```
<prefix>| - vertical split
<prefix>- - horizontal split
```

#### Sessions

```
<prefix>:new -s <session-name> - creates new session
<prefix>s - open session list
<prefix>w - open session list with tabs
```

#### Navigation

```
<ctrl>h - go to left split
<ctrl>l - go to right split
<ctrl>k - go to top split
<ctrl>j - go to bottom split
```

#### Copy mode

```
<prefix><c-]> - activate copy mode
v - start copy selection
y - copy selection
p - paste selection
```

Tmux is very powerfull tool. Once you learn it, you don't care what terminal emulator do you use. You don't have to relay on windows and tabs support from terminal. You can run tmux in any terminal.

Here you can find my [.tmux.config](https://github.com/atsman/env-automation/blob/master/roles/tmux/templates/.tmux.conf.j2)

## Editor - Nvim 

> [Nvim][Neovim Github] - a community-driven, refactored version of vim.

Nvim is my main text editor. It allows me to edit text faster than anything else. It helped me to learn the right habits. You never take hands off the keys, keeping them in an optimum position to input text, to scroll, to navigate or to apply commands.

<img src="/static/images/developer_enviroment_productivity/nvim-screen.png" size="medium" />

To get the max out of it heavy customization and learning required.

How is it configured in my case? You can find config files here: [.nvimrc](https://github.com/atsman/env-automation/tree/master/roles/nvim/templates)

* Plugin management - [vim-plug][VimPlug Github]
* File explorer - [nerdtree][Nerdtree Github]
* Navigation / Search - [fzf][FZF Github], [fzf.vim][FZF Vim Github], [ripgrep][RipGrep Github]
* Autocomplete - [YouCompleteMe][YCM Github]
* Linting - [ale][Ale Github]
* Git - [vim-fugitive][Vim Fugitive Github], [vim-gitgutter][Vim GitGutter Github], [gv.vim][GV Github]

### Nvim - Plugin management

After I tried a list of different plugin managers for Nvim, the best expirience provides [vim-plug][VimPlug Github] for the next reasons:

* **On-demand plugin loading** - when you open editor, it loads only plugins required for a particular file type. That helps to keep start up time fast.
* **Fast installation / update** - uses shadow clones and parallel installation.

Configuration example:

```viml
Plug 'w0rp/ale' " Load on start
Plug 'fatih/vim-go', { 'for': 'go' } " Load only for Go files 
Plug 'pangloss/vim-javascript', { 'for': 'javascript' }
Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
Plug 'rust-lang/rust.vim', { 'for': 'rust' }
```

Full config you can find here: [plugins.vim](https://github.com/atsman/env-automation/blob/master/roles/nvim/templates/plugins.vim)

### Nvim - File tree

The [Nerdtree][Nerdtree Github] plugin allows browsing directories and manipulating files. It presents the filesystem in the form of the tree, which you navigate in Vim style.

<img src="/static/images/developer_enviroment_productivity/nvim_nerdtree.gif" size="medium" round shadow />

### Nvim - Navigation / Search

Search and navigation is done via [fzf][FZF Github]. It is a generic command-line fuzzy finder. It can be used to search in any list: files, command history, processes, hostnames, bookmarks, git commits. From the shell it is used to execute commands from command history, to select git branches, to choose npm scripts and so on.

From inside of the editor it is used via [fzf.vim][FZF Vim Github] to search for files by filename and to quickly jump between buffers. To search by files content, fzf is used in conjunction with [ripgrep][RipGrep Github], which is grep rewritten in rust.


<img src="/static/images/developer_enviroment_productivity/nvim_fzf_search.gif" size="medium" round shadow />

### Nvim - Autocomplete - 

Having editor to predict what are you going to type is must have nowadays. So far the expirience with autocompletion I had with [YouCompleteMe][YCM Github].

### Linting - [**Ale**][Ale Github]

While writing code automatic formating and linting is must-have. The best vim plugin for that is [Ale][Ale Github]. It provides integration with most linting, formating tools and to LSP servers. 

Reasons to use it:

* async execution of linters / fixers
* list of integrations is huge

### Nvim - Shortcuts

```
<leader> - <space>
```

#### Tabs

```
<leader>tt - new tab
<leader>tp - go to prev tab
<leader>tn - go to next tab
<leader>to - close all tabs expect current one

<leader>1 - go to 1 tab
<leader>2 - go to 2 tab
.
<leader>n - go to nth tab
<leader>0 - go to last tab
```

#### Splits

```
<c-h> - go to left split
<c-j> - go to bottom split
<c-k> - go to top split
<c-l> - go to left split
<c-\> - go between split
<c-w>o - close all splits except focused one
```

#### File explorer

While buffer is in focus:
```
<leader>fe - toggle file tree
<leader>ff - find current file
```

While the file tree is in focus:
```
t - open file in new tab
i - open file in a hsplit
s - open file in a vsplit
o / enter - open file in the main buffer
```

#### File path / name

```
<leader>cfn - copy current filename to clipboard
<leader>cfp - copy current filepath to clipboard
```

#### Search

```
<ctrl>p - search files by filename
<ctrl>f - search files by content
<ctrl>b - search buffers by filename
```

#### Lint / Format

```
<leader>lt - lint
<leader>fx - fix
<leader>de - show detailed error
```

#### Git

```
<leader>gpr - git pull -r
<leader>gc - git commit
<leader>gp - git push
<leader>gb - git blame
<leader>gl - git log
<leader>gd - git diff in vertical split
```

## Shell - Zsh

[Neovim Github]: https://github.com/neovim/neovim
[VimPlug Github]: https://github.com/junegunn/vim-plug
[Nerdtree Github]: https://github.com/scrooloose/nerdtree
[FZF Github]: https://github.com/junegunn/fzf
[FZF Vim Github]: https://github.com/junegunn/fzf.vim
[Ripgrep Github]: https://github.com/BurntSushi/ripgrep
[YCM Github]: https://github.com/ycm-core/YouCompleteMe
[Ale Github]: https://github.com/dense-analysis/ale
[Vim Fugitive Github]:https://github.com/tpope/vim-fugitive
[Vim GitGutter Github]: https://github.com/airblade/vim-gitgutter
[GV Github]: https://github.com/junegunn/gv.vim
[Tmux Github]: https://github.com/tmux/tmux
[Alacritty Github]: https://github.com/jwilm/alacritty
[env-automation]: https://github.com/atsman/env-automation
